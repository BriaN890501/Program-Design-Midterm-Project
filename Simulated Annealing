#include <iostream>
#include<bits/stdc++.h>
#pragma optimize("Ofast")
using namespace std;

clock_t t = clock(); // time function (ms)

const int max_n = 1000, max_m = 10000; // max parameters

const int max_point = 100, max_k = 50;

// definition
int n, m, w, d; // map size / threat point amount / turning cost /max distance (not considered)

int X[max_m] = {0}, Y[max_m] = {0}, R[max_m] = {0}, P[max_m] = {0}; // coordinate (X, Y) / radius / threat point weight

int sx, sy, ex, ey; // coordinate of start and end points

// defining functions
void SimulatedAnnealing(); //  (main algorithm)

void UpdateSolution(double routeX[], double routeY[], double tempRouteX[], double tempRouteY[], double &tempthreat, int &points, int c);

int PointsOfRoute(double route[]); // points

double threat(double routeX[], double routeY[]); // threat function

int main()
{
    // setting time as the seed of rand()
    srand((unsigned)time(NULL));

    // cin
    cin >> n >> m >> w >> d;

    for(int i = 0; i < m; i++)
    {
        cin >> X[i];
    }

    for(int i = 0; i < m; i++)
    {
        cin >> Y[i];
    }

    for(int i = 0; i < m; i++)
    {
        cin >> R[i];
    }

    for(int i = 0; i < m; i++)
    {
        cin >> P[i];
    }

    cin >> sx >> sy >> ex >> ey;
    
    while(clock() - t < 900) // while time < 900ms
    {
        SimulatedAnnealing();
    }
    
    /*double A[max_point],B[max_point]; // test code
    for(int i=7;i<max_point;i++){
        A[i]=B[i]=-1;
    }
    for(int i=0;i<7;i++){
        cin>>A[i]>>B[i];
    }
    cout<<threat(A,B);*/

    return 0;
}
void SimulatedAnnealing()
{
    // definition and initialization
    double routeX[max_point], routeY[max_point]; // the x,y coordinate of the i th point in the route
    routeX[0] = sx;
    routeY[0] = sy;
    routeX[1] = ex;
    routeY[1] = ey;

    for(int i = 2; i < max_point; i++) // assign -1 to other values
    {
        routeX[i] = -1;
        routeY[i] = -1;
    }
    
    int k = max_k; // current max_k : 50

    // finding other routes
    double tempthreat = threat(routeX, routeY); // temporary threat value (only start and end)
    
    int temppoints = 2; // temporary point amount (only start and end)

    for(; k; k--)
    {
        // decide which to choose
        int choose = rand() % 3; // randomly choose 1 of 3 methods of new route (maybe consider uneven probability?)
        
        // 0 for adding a point between s and e
        if(choose == 0 && temppoints != max_point) // check point amount
        {
            //cout<<k<<" "<<1<<endl; // test code
            
            // making a temporary route
            double tempRouteX[max_point], tempRouteY[max_point];

            for(int i = 0; i < max_point; i++) // copy route to tempRoute
            {
                tempRouteX[i] = routeX[i];
                tempRouteY[i] = routeY[i];
            }

            // making a random integer between 1 to temppoints-1
            int a = rand() % (temppoints - 1) + 1;

            // finding coordinate within the rectangle of a & a-1 point
            double x = rand() % static_cast<int> (tempRouteX[a] - tempRouteX[a - 1] + 1) + tempRouteX[a - 1];
            double y = rand() % static_cast<int> (tempRouteY[a] - tempRouteY[a - 1] + 1) + tempRouteY[a - 1];

            // shift points after a th point right
            if( ( abs( x-tempRouteX[a-1] ) > 0.1 || abs( y-tempRouteY[a-1] ) > 0.1 ) && ( abs( x-tempRouteX[a] ) > 0.1 || abs( y-tempRouteY[a] ) > 0.1 ) )// the new point does not equal to a & a-1 point
            {
                for(int i = temppoints; i > a; i--)
                {
                    tempRouteX[i] = tempRouteX[i - 1];
                    tempRouteY[i] = tempRouteY[i - 1];
                }

                // insert the point
                tempRouteX[a] = x;
                tempRouteY[a] = y;

                UpdateSolution(routeX, routeY, tempRouteX, tempRouteY, tempthreat, temppoints, 1); // status 1
            }
        }

        // 1 for taking a point out between s and e
        else if(choose == 1 && temppoints != 2) // check point amount
        {
            //cout<<k<<" "<<2<<endl; // test code
            
            // making a temporary route
            double tempRouteX[max_point], tempRouteY[max_point];
            for(int i = 0; i < max_point; i++) // copy
            {
                tempRouteX[i] = routeX[i];
                tempRouteY[i] = routeY[i];
            }

            // making a random integer between 2 to temppoint-1
            int a = rand() % (temppoints - 2) + 2;

            // shift point after a th point left
            for(int i = a; i < temppoints; i++)
            {
                tempRouteX[i - 1] = tempRouteX[i];
                tempRouteY[i - 1] = tempRouteY[i];
            }

            // delete the last point
            tempRouteX[temppoints - 1] = -1;
            tempRouteY[temppoints - 1] = -1;

            UpdateSolution(routeX, routeY, tempRouteX, tempRouteY, tempthreat, temppoints, 2); // status 2
        }

        // 2 for changing the coordinate of a point
        else if(choose == 2 && temppoints != 2)
        {
            //cout<<k<<" "<<3<<endl; // test code
            
            // making a temp route
            double tempRouteX[max_point], tempRouteY[max_point];

            for(int i = 0; i < max_point; i++) // copy
            {
                tempRouteX[i] = routeX[i];
                tempRouteY[i] = routeY[i];
            }
            // making a random integer between 2 to temppoints -1
            int a = rand() % (temppoints - 2) + 2;

            // finding coordinate within the rectangle of a & a-2 point
            double x = rand() % static_cast<int>(tempRouteX[a] - tempRouteX[a - 2] + 1) + tempRouteX[a - 2];
            double y = rand() % static_cast<int>(tempRouteY[a] - tempRouteY[a - 2] + 1) + tempRouteY[a - 2];

            if( ( abs(x-tempRouteX[a-2])>0.1 || abs(y-tempRouteY[a-2])>0.1 ) && ( abs(x-tempRouteX[a])>0.1 || abs(y-tempRouteY[a])>0.1 ) )
            {
                // changing the coordinate of a-1 point
                tempRouteX[a - 1] = x;
                tempRouteY[a - 1] = y;

                UpdateSolution(routeX, routeY, tempRouteX, tempRouteY, tempthreat, temppoints ,3); // status 3
            }
        }
    }
}

void UpdateSolution(double routeX[], double routeY[], double tempRouteX[], double tempRouteY[], double &tempthreat, int &temppoint, int c)
{

    double Threat = threat( tempRouteX, tempRouteY );
    
    //cout<<"up "<<Threat<<" "<<tempthreat<<" "<<temppoint<<" "; // test code
    
    if( tempthreat > Threat ) // update solution if better (less threat)
    {
        //cout<<"yes"; // test code
        
        for(int i = 0; i < max_point; i++) // update solution
        {
            routeX[i] = tempRouteX[i];
            routeY[i] = tempRouteY[i];
        }

        tempthreat = Threat; // update threat value

        if(c==1)
        {
            temppoint++;
        }
        
        if(c==2)
        {
            temppoint--;
        }

    }//cout<<endl; // test code
}

int PointsOfRoute(double route[]) // point amount
{
    int i = 2;
    
    while(route[i] >= 0)
    {
        i++;
        
        if(i == max_point)
        {
            break;
        }
    }
    
    return i;
}

double threat(double routeX[], double routeY[]) // threat function
{
    int P = PointsOfRoute(routeX); // points
    double newX = routeX[0];
    double newY = routeY[0];
    double threat = 0;
    double leftdis = 0; // distance left
    double dis;
    for(int i = 1; i < P; i++)
    {
        double DisBetDots = sqrt(pow(routeX[i] - routeX[i - 1], 2) + pow(routeY[i] - routeY[i - 1], 2));
        double vecX = (routeX[i] - routeX[i - 1]) / DisBetDots;
        double vecY = (routeY[i] - routeY[i - 1]) / DisBetDots;
        int j = 0;

        for(;DisBetDots - 1 > -0.001; j++)
        {
            if(j == 0)
            {
                newX = newX + (1 - leftdis) * vecX;
                newY = newY + (1 - leftdis) * vecY;
                DisBetDots = DisBetDots - (1 - leftdis);
                leftdis = 0;
            }
            else
            {
                newX = newX + vecX;
                newY = newY + vecY;
                DisBetDots = DisBetDots - 1;
            }
            //cout<<newX<<" "<<newY<<endl;
            if(abs(newX-routeX[P-1])<0.01&&abs(newY-routeY[P-1])<0.01){
                break;
            }

            for(int k = 0; k < m; k++)
            {
                dis = sqrt(pow(X[k] - newX, 2) + pow(Y[k] - newY, 2));
                if(dis > R[k])
                    continue;
                threat = threat + P[k] * ((R[k] - dis) / R[k]);
            }

        }

        leftdis = DisBetDots;
        newX = routeX[i];
        newY = routeY[i];
        //cout<<newX<<" "<<newY<<endl;

    }
    threat = threat + w * (P - 2);

    return threat;
}
